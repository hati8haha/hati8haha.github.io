[{"title":"API 是什麼","url":"/2021/12/01/API%20%E6%98%AF%E4%BB%80%E9%BA%BC/","content":"API 是 Application Programming Interface 的縮寫，中文稱作「應用程式介面」，是應用程式之間用以進行資料交換的介面。\n例如我想取用 twitch 的實況人數資料，這時就可以從 twitch 的 API 取得資料；或著我想在網站上新增 PayPal 付款的功能，這時就可以透過 PayPal API 實現功能。\n從上面的例子可以知道，如果要利用別人已經建立好的資料、函式庫或功能，這時就可以透過 API 來實現。而作為使用者與被使用者之間的橋樑，就是 API 這個介面。\n","categories":["前端"],"tags":["web 基礎"]},{"title":"AWS EC2 Nginx + pm2 完整部署流程","url":"/2021/12/01/AWS%20EC2%20Nginx%20+%20pm2%20%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/","content":"\nEC2 新建 instance\n連線到 VPS\n安裝 nginx\n防火牆設置\n\n\n到 &#x2F;var&#x2F;www&#x2F; git clone 專案\nAWS RDS 新建 mysql 資料庫\n專案中補上連線資料庫用的帳號密碼\n安裝 node.js、npm\n安裝 npm packages\n安裝 sequelize-cli\n執行 sequelize 建立資料庫、資料表\nsequelize db:create\nsequelize db:migrate\n\n\n安裝 pm2\n執行 pm2 sudo pm2 start index.js\n到 &#x2F;etc&#x2F;nginx&#x2F;sites-available 建立檔案 “example.com”\n檔案內容如下，修改域名與 portserver &#123;     listen       80;     server_name  example.com;     # 把 request 轉給 localhost 的 5566 port     location / &#123;       proxy_pass http://127.0.0.1:5566;     &#125; &#125;\n 參考自：俄羅斯不愧是戰鬥民族：nginx\n\n\n\n到 etc&#x2F;nginx&#x2F;sites-enabled 執行 sudo ln -s /etc/nginx/sites-available/example /etc/nginx/sites-enabled/，會建立連結檔案\n重新載入 nginx sudo systemctl reload nginx\n部署成功！&#96;\n\n","categories":["DevOps"],"tags":["部屬","AWS","Nginx"]},{"title":"AWS EC2 nginx + pm2 部署踩雷紀錄","url":"/2021/12/01/AWS%20EC2%20nginx%20+%20pm2%20%E9%83%A8%E7%BD%B2%E8%B8%A9%E9%9B%B7%E7%B4%80%E9%8C%84/","content":"port 22: Connection refused 重啟 instance 後無法連線 ssh -i &quot;mykey.pem&quot; ubuntu@ec2-3-144-77-50.us-east-2.compute.amazonaws.com\n&#x3D;&gt; 拿掉雙引號 ssh -i mykey.pem ubuntu@ec2-3-144-77-50.us-east-2.compute.amazonaws.com\npm2 任務無法執行查看 logsudo pm2 log \nubuntu@ip-172-31-38-203:/var/www/hati8haha.tw/hati8haha.tw$ sudo pm2 log 0[TAILING] Tailing last 15 lines for [0] process (change the value with --lines option)/root/.pm2/logs/index-out.log last 15 lines:0|index    | Example app listening on port 5001!0|index    | Example app listening on port 5001!0|index    | Example app listening on port 5001!0|index    | Example app listening on port 5001!0|index    | Example app listening on port 5001!/root/.pm2/logs/index-error.log last 15 lines:0|index    |     at listenInCluster (node:net:1363:12)0|index    |     at Server.listen (node:net:1450:7)0|index    |     at Function.listen (/var/www/hati8haha.tw/hati8haha.tw/node_modules/express/lib/application.js:610|index    |     at Object.&lt;anonymous&gt; (/var/www/hati8haha.tw/hati8haha.tw/index.js:52:5)0|index    |     at Module._compile (node:internal/modules/cjs/loader:1101:14)0|index    |     at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)0|index    |     at Module.load (node:internal/modules/cjs/loader:981:32)0|index    |     at Function.Module._load (node:internal/modules/cjs/loader:822:12)0|index    |     at Object.&lt;anonymous&gt; (/usr/lib/node_modules/pm2/lib/ProcessContainerFork.js:33:23) &#123;0|index    |   code: &#x27;EADDRINUSE&#x27;,0|index    |   errno: -98,0|index    |   syscall: &#x27;listen&#x27;,0|index    |   address: &#x27;::&#x27;,0|index    |   port: 50010|index    | &#125;\n查看 port輸入 netstat -lntp\n(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program nametcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -tcp6       0      0 :::5001                 :::*                    LISTEN      17643/node /var/wwwtcp6       0      0 :::80                   :::*                    LISTEN      -tcp6       0      0 :::22                   :::*                    LISTEN      -\n嘗試 kill pid 失敗ubuntu@ip-172-31-38-203:/var/www/hati8haha.tw/hati8haha.tw$ lsof -i :5001COMMAND     PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEnode\\x20/ 17998 ubuntu   20u  IPv6  79493      0t0  TCP *:5001 (LISTEN)ubuntu@ip-172-31-38-203:/var/www/hati8haha.tw/hati8haha.tw$ sudo kill -9 17998ubuntu@ip-172-31-38-203:/var/www/hati8haha.tw/hati8haha.tw$ lsof -i :5001COMMAND     PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\n\n可能解決方法參考自進度報告 8&#x2F;10 \n\n同學遇到的 node 佔用 port 的問題今天我也遇到了，因為寫註冊資料感覺有成功但是 iTerm 上又沒有任何訊息跑出來，所以懷疑是 port 的問題。解決方法用 kill PID 是殺不掉的，要用 killall -9 node ，stackoverflow 又再一次順利地解決我的問題＾＾\n\n套件安裝失敗ubuntu@ip-172-31-2-168:/var/www/hati8haha.tw$ npm install expressnpm WARN checkPermissions Missing write access to /var/www/hati8haha.tw/node_modules/expressnpm WARN checkPermissions Missing write access to /var/www/hati8haha.tw/node_modulesnpm WARN hw1@1.0.0 No descriptionnpm ERR! code EACCESnpm ERR! syscall accessnpm ERR! path /var/www/hati8haha.tw/node_modules/expressnpm ERR! errno -13npm ERR! Error: EACCES: permission denied, access &#x27;/var/www/hati8haha.tw/node_modules/express&#x27;npm ERR!  [Error: EACCES: permission denied, access &#x27;/var/www/hati8haha.tw/node_modules/express&#x27;] &#123;npm ERR!   errno: -13,npm ERR!   code: &#x27;EACCES&#x27;,npm ERR!   syscall: &#x27;access&#x27;,npm ERR!   path: &#x27;/var/www/hati8haha.tw/node_modules/express&#x27;npm ERR! &#125;npm ERR!npm ERR! The operation was rejected by your operating system.npm ERR! It is likely you do not have the permissions to access this file as the current usernpm ERR!npm ERR! If you believe this might be a permissions issue, please double-check thenpm ERR! permissions of the file and its containing directories, or try runningnpm ERR! the command again as root/Administrator.npm ERR! A complete log of this run can be found in:npm ERR!     /home/ubuntu/.npm/_logs/2021-08-12T09_16_56_297Z-debug.logubuntu@ip-172-31-2-168:/var/www/hati8haha.tw$ sudo npm i bcryptjs\n\n解決方法不要用  sudo apt install npm\n用 curl -fsSL https://deb.nodesource.com/setup_16.x | sudo -E bash - sudo apt-get install -y nodejs 安裝\n網址：NodeSource Node.js Binary Distributions \n","categories":["DevOps"],"tags":["部屬","AWS","Nginx"]},{"title":"BOM DOM 差別","url":"/2021/12/01/BOM%20DOM%20%E5%B7%AE%E5%88%A5/","content":"JavaScript 並沒有提供網頁的操作方法，前端開發者在網頁的操作方法都是「瀏覽器」（JavaScript 操作平台）提供的。\n這些操作方法基本上會分別由這兩種物件所擁有：「BOM」與「DOM」。『BOM』完全依賴瀏覽器廠商實作本身沒有標準規範，『DOM』有W3C所制定的標準來規範。\nBOMBOM (Browser Object Model，瀏覽器物件模型)BOM 核心是 window 物件。和網頁本身的內容無關。\nDOMDOM (Document Object Model，文件物件模型)\n操作網頁內容時，就須透過 DOM。\n如上圖所示，每一個 HTML 標籤就是一個節點。DOM 提供的 API 就是讓 JavaScript 可以改變、存取 HTML 樣式、架構及內容的方法。還有，對節點的綁定事件。\n","categories":["前端"],"tags":["DOM","BOM","瀏覽器"]},{"title":"Ajax","url":"/2021/12/01/Ajax/","content":"什麼是 Ajax？Ajax 全名是 Asynchronous JavaScript and XML，指的是非同步的 JavaScript 與 XML。\nJavascript 指的是使用的程式語言，而 XML 則是交換資料的類型（現在也不限於 XML、許多 API 都採用 JSON 格式），至於非同步呢？\n首先來釐清什麼是非同步，與同步之間的差異是什麼？\n同步與非同步同步：一般在執行 JavaScript 時，程式是逐行往下執行的，下一行的程式需要等到上一行執行完畢，才會開始執行下一行。\nlet i = 0while (i &lt; 100000000000) &#123;  //需要執行相當多次的迴圈，會花費一定時間i++&#125;console.log(i)  //等到上一行結束時才會執行。若是非同步的話則不能確保 i 的值為多少\n同步請求（Synchronous request）：當今天程式涉及網路時，若發送 request 與接收 response 是採用同步的形式進行，被稱作同步請求。\nlet result = sendRequest(&#x27;https://api.twitch.tv/kraken/games/top?client_id=xxx&#x27;)console.log(result) //等到收到 response 才會執行\n由於要等到收到 response 才能執行接下來的程式，因此會需要花費相當的時間。更重要的是，在等待的時間 什麼事都不能做，由於同步的關係，程式會停留在等待收 response 的階段，若等待時間相當長，結果就是造成糟糕的使用者體驗，像是下面這張圖。\n\n非同步：非同步則代表不必等待上一行完全執行完畢，就可以先執行下一行。例如再 DOM 中常運用的 addEventListener 中的 callback function 並不會直接執行，而是等到監聽事件發生時才會執行。\ndocument.querySelector(&#x27;div&#x27;).addEventListener(&#x27;click&#x27;, callbackFunction)//callback function 不會直接執行，這也算是非同步表現\n\n非同步請求（Asynchronous request）：在現代的網業中大多程式會採用非同步的方式發送 request，採用非同步的好處是網頁不必等待收到 response 才能進行下一個動作。可以先執行其他部分，若收到 response 再把收到的內容與既有內容融合呈現。\nAjax 實例在 JavaScript 中，可以透過瀏覽器準備好的物件 XMLHttpRequest 發送非同步方式的 request。\n以下是參考自輕鬆理解 Ajax 與跨來源請求一文的程式碼：\nvar request = new XMLHttpRequest();request.open(&#x27;GET&#x27;, `https://api.twitch.tv/kraken/games/top?client_id=xxx`, true);request.onload = function() &#123;  if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123;      // Success!    console.log(request.responseText);  &#125;&#125;;request.send();\n\n用 Ajax 與我們用表單送出資料的差別在哪？表單用表單送出資料時，頁面會先跳轉再送出 request。表單是瀏覽器內建就有的功能，若瀏覽器有禁用 Javascript 依然可以發送 request。若是以 GET 的方式發送 request，則表單資訊會附加在 url 中送出。\nAjax使用 Ajax 傳送資料時不需要跳轉頁面，資料以非同步的方式傳送。送出 request 的同時，網頁其他部分可以繼續運作。若瀏覽器有禁用 Javascript 的話就不能用 Ajax 的方式發送表單。\n兩者比較\n\n\n\n表單\nAjax\n\n\n\n頁面跳轉\n需要\n不需\n\n\n需要什麼才能進行\n瀏覽器\nJavascript\n\n\nJSONP 是什麼？JSONP 的全名是 JSON with Padding，是一種可以進行跨來源請求的方法。原理是利用 &lt;script&gt;&lt;/script&gt; 標籤可以跨網域的特性，將遠端的資料利用 callback function 帶入本地端。\n&lt;script href=&quot;https://another-origin.com/api/&quot;&gt;&lt;/script&gt;&lt;script&gt;  function receiveData (response) &#123;    console.log(response);  &#125;&lt;/script&gt;\n若此時 https://another-origin.com/api/ 返回的內容如下：\nreceiveData(&#123;  data: &#x27;test&#x27;&#125;);\n透過函式，那麼原本 html 中的 javascript 便可以存取來自其他網域的資料。\nJSONP 的缺點是附加的參數（例如：client-ID 等）只能透過附加在 url 上傳送，也只能使用 GET 方法發送 request，無法使用 POST 或其他 request 方法。\n","categories":["前端","JavaScript"],"tags":["JavaScript"]},{"title":"CORS","url":"/2021/12/01/CORS/","content":"CORS，全名為 Cross-origin resource sharing，中文為跨來源資源共用。由於瀏覽器基於安全性的考量，因此會有同源政策 Same Origin Policy 的限制，會阻止跨網域的 request。為了解決存取跨網域的需求，因此有了 CORS 規範，告訴使用者若要進行跨網域的請求的話該如何進行。\n若發送一個 request 至跨網域的 API，那麼回傳的 response 的 header 中會有 acess-control-allow-origin: 一欄。該欄會標示有哪些網域是允許可以存取的，若該欄的值為 *，代表所有網域都可以進行存取。\n","categories":["前端"],"tags":["資安","CORS"]},{"title":"CSRF 的攻擊原理以及防範方法","url":"/2021/12/01/CSRF%20%E7%9A%84%E6%94%BB%E6%93%8A%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E9%98%B2%E7%AF%84%E6%96%B9%E6%B3%95/","content":"攻擊原理CSRF 的全名為 Cross Site Request Forgery，中文名為「跨站請求偽造」，也被稱為 one-click attack。\nCSRF 的攻擊模式是在使用者連線至惡意網站時，以 client 端儲存的 cookie 或 session 偽造使用者發送的 request，達到攻擊目的。\n例如小明在登入網路銀行之後，在開啟新分頁玩小遊戲，但小遊戲網頁卻有隱藏的惡意連結，會發送轉帳的 request，因為有網路銀行的 session 是登入狀態，因此小明的錢就莫名其妙被轉帳到駭客帳戶了。\n防範方法：檢查 Referer、CSRF tokenCSRF 的 reuqest 跟使用者本人發出的 request 的不同就在於發送 request 的 domain 一個是來自不同 domain，另一個則是來自同 domain。檢查 Referer、CSRF token 兩種方法都是透過此概念實行的防禦手段。\n\n檢查 Refererrequest 的 header 裡面會帶一個欄位是 referer ，可以從 referer 這個欄位看到該 request 是從哪發送的。因此可以透過此方式檢查是否為跨站 request。但有部分瀏覽器不會帶 referer 或使用者會關掉自動帶 referer 功能，同時檢查 referer 的程式若沒寫好可能會有漏洞。\nCSRF tokenCSRF token 是產生一組只有使用者知道的隨機 token，在發送 request 時需要帶上這個 token 才能通過驗證。CSRF token 有儲存在 server 端或儲存在 client 端的作法。因為攻擊者的沒辦法讀寫目標網站的 cookie，所以可以用來驗證是否為跨 domain 的 request。\n\n","categories":["前端"],"tags":["資安","CSRF"]},{"title":"CSS Selector 權重的計算方式","url":"/2021/12/01/CSS%20Selector%20%E6%AC%8A%E9%87%8D%E7%9A%84%E8%A8%88%E7%AE%97%E6%96%B9%E5%BC%8F/","content":"基本選擇器權重計算CSS Selector 的權重計算方式如下：\n\n計算 ID 選擇器的數量（設想為變數 a）\n計算 Class 與 Attributes 選擇器（包含 Pseudo Class）的數量（設想為變數 b）\n計算標籤選擇器的數量（設想為變數 c）\n將 a、b、c 串接在一起，即可得到權重\n\n範例：\n*               /* a=0 b=0 c=0 -&gt; 權重 =   0 */LI              /* a=0 b=0 c=1 -&gt; 權重 =   1 */UL LI           /* a=0 b=0 c=2 -&gt; 權重 =   2 */UL OL+LI        /* a=0 b=0 c=3 -&gt; 權重 =   3 */H1 + *[REL=up]  /* a=0 b=1 c=1 -&gt; 權重 =  11 */UL OL LI.red    /* a=0 b=1 c=3 -&gt; 權重 =  13 */LI.red.level    /* a=0 b=2 c=1 -&gt; 權重 =  21 */#x34y           /* a=1 b=0 c=0 -&gt; 權重 = 100 */#s12:not(FOO)   /* a=1 b=0 c=1 -&gt; 權重 = 101 */\n其中，a、b、c 計算後所得的權重並不是代表百位數、十位數、個位數，而是會依照 a、b、c 的順序進行比較，見下方範例：\n.pink.pink.pink.pink.pink.pink.pink.pink.pink ... .pink/* 101 個 .pink，權重為 0-101-0 */#login-button/* 權重為 100-0-0 */\ninline style 與 !importantCSS Selector 權重也需要考慮到 inline style 與 !important，這兩者的權重計算可以視為優先於上述選擇器權重。\n根據 MDN 所介紹\n\nInline styles added to an element (e.g., style=&quot;font-weight: bold;&quot;) always overwrite any styles in external stylesheets, and thus can be thought of as having the highest specificity.\n\nInline styles 可以直接覆蓋過 stylesheets 中的樣式\n\nWhen an important rule is used on a style declaration, this declaration overrides any other declarations. Although technically !important has nothing to do with specificity, it interacts directly with it.\n\n!important 則是不列入權重計算，有該註記的樣式會直接被套用\n總結CSS Selector 權重可以用以下一行簡單說明：\n!important &gt; inline styles &gt; ID 選擇器 &gt; Class 選擇器 &gt; Html 標籤選擇器\n","categories":["前端","CSS"],"tags":["CSS"]},{"title":"Cookie 是什麼？如何設定？","url":"/2021/12/01/Cookie%20%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A8%AD%E5%AE%9A%EF%BC%9F/","content":"由於 HTTP 是無狀態的，因此每一個 Request 不相關，Server 會無法辨識是否為同個使用者。\n而 Cookie 存在的目的就是為了讓 Server 能辨識使用者，透過 Cookie 這個儲存在瀏覽器的小型文字檔案，Server 便能辨識不同的 Request 是否來自同個使用者。\n透過讓 Server 發送 Cookie 給瀏覽器，而瀏覽器將 Cookie 儲存起來，以便讓 Server 能辨識使用者。\n在 Server 發送 設定 Cookie 的 response 給 Client 端之後，Client 發送到 Server 的 request 的 header 中會帶上 cookie。\ngraph LRA[Client] -- rquest --&gt; B[Server]B -- Response with setCookie --&gt; A\ngraph LRA[Client] -- rquest with Cookie --&gt; B[Server]B -- 可以辨識使用者 --&gt; A\n在 php 實作中，可以用 setcookie() 來設定 cookie，可參考此範例：setcookie(&quot;cookie 名稱&quot;, cookie 參數, 失效時間)time() 會回傳現在時間\n  &lt;?php  $expire = time() + 3600 * 24 * 30;  //沒設時間會很快失效  setcookie(&quot;username&quot;, $username, $expire)?&gt;\n","categories":["前端"],"tags":["web 基礎","cookie"]},{"title":"DNS","url":"/2021/12/01/DNS/","content":"什麼是 DNS？Google 有提供的公開的 DNS，對 Google 的好處以及對一般大眾的好處是什麼？DNS 為 Domain Name System 縮寫，中文為網域名稱系統，是用來管理域名與 IP 位址對應關係的一項服務。\nDNS 的運作方式像電話簿，裏頭有網域名稱與 IP 位址。當使用者在輸入網址時，url 會被傳到 DNS 解析為 IP 位址，讓使用者可以連上對應的主機。\n若更深入理解 DNS，就會發現 DNS 的運作主要涉及 4 個部分，分別為：\n\nDNS 遞迴程式（DNS Recursive Resolver）\n根名稱伺服器（DNS Root Nameserver）\nTLD 名稱伺服器（DNS TLD Namerserver）\n權威名稱伺服器（Authoritative Nameserver）\n\n\n公開的 DNS 好處對於使用者\n更新速度快\n安全性較好\n上網速度較快\n減少重新導向\n\n對於 Google\n更容易掌握使用者的瀏覽的網頁\n\n","categories":["前端"],"tags":["web 基礎"]},{"title":"DOM","url":"/2021/12/01/DOM/","content":"DOM 為 Document Object Model 的縮寫，中文為文件物件模型。\n透過 DOM，可以將 html 文件以物件的形式提供給程式進行存取，進而可以改變 html 的架構、style 以及內容。而這個物件是根據 html 中的標籤所建立出的樹狀結構，html 中的標籤在樹狀結構上會以節點表示。DOM 的樹狀結構可參考下圖：\n\n有了 DOM 之後，Javascript 便可以呼叫 DOM API 來對 html 文件內容進行操作。\n如果要透過 DOM API 取得元素內容，可以使用以下幾種方式：\n\ndocument.getElementById(&quot;elementID&quot;)依據元素 ID 取得元素\ndocument.getElementsByTagName(&quot;elementTagName&quot;)依據標籤選取所有符合的元素\ndocument.getElementByClassName(&quot;elementClassName&quot;)依據 Class 選取所有符合的元素\ndocument.querySelector(&quot;.elementClass&quot;)使用 CSS 選擇器的方式選取元素，只會選取到符合的第一個元素\ndocument.querySelectorAll(&quot;div&quot;)使用 CSS 選擇器的方式選取所有符合的元素\n\n","categories":["前端"],"tags":["DOM","瀏覽器"]},{"title":"Express 筆記","url":"/2021/12/01/Express%20%E7%AD%86%E8%A8%98/","content":"Expressgraph LRA[瀏覽器] --&gt; B[Express Server]B --&gt;A\nApache + PHPgraph LRA[瀏覽器] --&gt; B[Apache Server]B --&gt; C[PHP]C --&gt; BB --&gt;A\n需要透過中間的 Apache Server，會受到檔案路徑的限制（可修改）\nMVCgraph LRA[request] -- resquest --&gt; B[Controller]B --&gt; C((Model)) B -- data --&gt; D((View))C -- data --&gt; BD -- 完整的 response --&gt; BB -- response --&gt;A\nExpress 基本架構實作 view安裝 template engines\nnpm install ejs\n\napp.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;)\n預設目錄會是 &#x2F;views，需新增資料夾 views，並在資料夾中新增 .ejs 檔案。\napp.get(&#x27;/todos&#x27;, (req, res) =&gt; &#123;  res.render(&#x27;todos&#x27;,&#123;  todos //ES6 若 key = value，可以省略  &#125;)&#125;)app.get(&#x27;/hello&#x27;, (req, res) =&gt; &#123;  res.render(&#x27;hello&#x27;)&#125;)\n\ntodo.ejs\n&lt;ul&gt;&lt;% for(let i = 0; i&lt;todo.length; i++) &#123;%&gt;  //&lt;%%&gt; 裡面可以寫 Js 語法  &lt;li&gt;&lt;% todo[i] %&gt;&lt;/li&gt;&lt;  &#125;%%&gt;\nindex.js\napp.get(&#x27;/todo/:id&#x27;, (req, res) =&gt; &#123;  //: 表示可以代參數  const id = req.params.id    //.params 代表參數，從網址把參數代進來  const todo = todos[id]  res.render(&#x27;hello&#x27;)&#125;)\n\n重構index.js\nconst express = require(&#x27;express&#x27;)const app = express()const port = 5001const todoController = require(&#x27;.controllers/todo&#x27;)app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;)app.get(&#x27;/todos&#x27;, todoController.getAll)app.get(&#x27;/todos/:id&#x27;, todoController.get)app.listen(port, () =&gt; &#123;  console.log(`Example app listening on port $&#123;port&#125;!`)&#125;)\n\n\n&#x2F;models&#x2F;todos.js\nconst todos = [  &#x27;first todo&#x27;, &#x27;second todo&#x27;, &#x27;third todo&#x27;]const todoModel = &#123;  getAll: () =&gt; &#123;    return todos  &#125;,     get: id =&gt; &#123;    return todos[id]  &#125;,&#125;module.exports = todoModel\n\n&#x2F;controller&#x2F;todo.js\nconst todos = require(&#x27;../models/todo&#x27;)const todoController = &#123;  getAll: (req, res) =&gt; &#123;    const todos = todoModel.getAll()    res.render(&#x27;todos&#x27;, &#123;      todos    &#125;)  &#125;,    get: (req, res) =&gt; &#123;    const id = req.params.id    const todo = todoModel.get(id)    res.render(&#x27;todo&#x27;, &#123;      todo    &#125;)  &#125;&#125;\n\n&#x2F;view&#x2F;todo.ejs\n&lt;h1&gt;Todo&lt;/h1&gt;&lt;h2&gt;&lt;%= todo %&gt;&lt;/h2&gt;\n\n&#x2F;view&#x2F;todos.ejs\n&lt;ul&gt;&lt;% for(let i = 0; i&lt;todo.length; i++) &#123;%&gt;  &lt;li&gt;&lt;% todo[i] %&gt;&lt;/li&gt;&lt;  &#125;%%&gt;\n\nNode.js 與 MySQL 的串接mysqljs Github\nnpm install mysql\ndb.js\nvar mysql      = require(&#x27;mysql&#x27;);var connection = mysql.createConnection(&#123;  host     : &#x27;localhost&#x27;,  user     : &#x27;root&#x27;,  password : &#x27;root&#x27;,  database : &#x27;app&#x27;&#125;);//connection.connect();module.export = connection// connection.query(&#x27;SELECT * from todos&#x27;, function (error, results, fields) &#123;//   if (error) throw error;//   console.log(results[0].content);// &#125;);// connection.end();\n\nnode db.js\n會印出 result，確認資料庫可連線\nindex.js\nconst = require(&#x27;./db&#x27;)\n\n","categories":["後端"],"tags":["Node.js","Express"]},{"title":"HTTP","url":"/2021/12/01/HTTP/","content":"為甚麼需要協定（protocol）標準 -&gt; 規模化\nHTTP 是啥？HTTP（HyperText Transfer Protocol）是全球資訊網資料通訊的基礎。\nHTTP request 的一生Charles 可以看瀏覽器\n瀏覽器 -&gt; 製造 request -&gt; 傳給 serverserver -&gt; 處理 -&gt; 傳 response 回來\nDNS Domain Name System\nnslookup github.com 查看 github 的 IP 位置\n瀏覽器\n發 request 到 DNS\n拿到 response 渲染\n根據回傳的 html 把資源下載\n\n沒有瀏覽器一樣可以拿到 response\nRequest - Simplified HTTP clientnpm install request\nHeader 與 BodyHeader額外資訊\nBody主要內容\nGET 與 POSTGETPOST要執行一些動作（例如登入）GET：GET 方法請求展示指定資源。使用 GET 的請求只應用於取得資料。HEAD：HEAD 方法請求與 GET 方法相同的回應，但它沒有回應主體（response body）。POST：POST 方法用於提交指定資源的實體，通常會改變伺服器的狀態或副作用（side effect）。PUT：PUT 方法會取代指定資源所酬載請求（request payload）的所有表現。DELETE：DELETE 方法會刪除指定資源。PATCH：PATCH 方法套用指定資源的部份修改。HTTP 請求方法\nHTTP 狀態碼HTTP 狀態碼\n301：永久移動到新位置302：暫時\n","categories":["前端"],"tags":["web 基礎"]},{"title":"HTML tag blockquote、object、code","url":"/2021/12/01/HTML%20tag%20blockquote%E3%80%81object%E3%80%81code/","content":"tags: HTML1. &lt;blockquote&gt;說明&lt;blockquote&gt; 標籤可以用來套用在引用的內容上，會以縮排方式呈現。要改變 &lt;blockquote&gt; 的縮排，需使用 CSS 的 margin 屬性。\n若要表示段落內的引文，則可以使用 &lt;q&gt; 來進行引用。\n可用屬性\ncite可以用來描述來源的 URL。不會有超連結，僅會在 html 中具有表達語意的功能。\n\n範例&lt;blockquote cite=&quot;https://hulitw.medium.com/variable-and-frontdesk-a53a0440af3c&quot;&gt;  &lt;p&gt;    不知道大家有沒有去過一些有寄物櫃的地方？&lt;br&gt;    我這邊講的不是健身房或是車站會看到的那種置物櫃，不是那種投幣以後讓你把東西放裡面，然後給你一個鑰匙的那種。那是自助式的置物櫃，我要談的不是那種。&lt;/p&gt;&lt;/blockquote&gt;\n\n\n不知道大家有沒有去過一些有寄物櫃的地方？我這邊講的不是健身房或是車站會看到的那種置物櫃，不是那種投幣以後讓你把東西放裡面，然後給你一個鑰匙的那種。那是自助式的置物櫃，我要談的不是那種。\n\n2. &lt;object&gt;說明&lt;object&gt; 標籤可以用來嵌入外部資源，例如 pdf 檔案或是已經被宣告死亡的 flash 等等。\n圖片、音檔、影片、網頁，分別有相對應的嵌入標籤（&lt;img&gt;、&lt;audio&gt;、&lt;video&gt;、&lt;iframe&gt;），較不適合以 &lt;object&gt; 嵌入。\n可用屬性以下只列出 html5 以後所適用的屬性：\n\ntype外部資源的 MIME 類型。\ndata外部資源的 URL。\nheight嵌入資源顯示的高度，單位是 pixel。\nwidth嵌入資源顯示的寬度，單位是 pixel。\nname指定此 object 的名稱。\nform此 object 關聯的 &lt;form&gt; 元素。\nusemap指定與 object 關聯的 &lt;map&gt; 元素的 hash-name。\n\n範例&lt;object type=&quot;application/pdf&quot;    data=&quot;/media/examples/In-CC0.pdf&quot;    width=&quot;250&quot;    height=&quot;200&quot;&gt;&lt;/object&gt;\n\n3. &lt;code&gt;說明&lt;code&gt; 標籤用來表示程式碼的內容，常與 &lt;pre&gt; 一起使用，可以保留空白與縮排呈現。\n可用屬性無\n範例&lt;p&gt;這是文字中的一段程式碼 &lt;code&gt;console.log(&quot;Hello World!&quot;)&lt;/code&gt; 好耶！&lt;/p&gt;\n這是文字中的一段程式碼 console.log(&quot;Hello World!&quot;) 好耶！\n","categories":["前端","HTML"],"tags":["HTML"]},{"title":"JSONP","url":"/2021/12/01/JSONP/","content":"JSONP 是什麼？JSONP 的全名是 JSON with Padding，是一種可以進行跨來源請求的方法。原理是利用 &lt;script&gt;&lt;/script&gt; 標籤可以跨網域的特性，將遠端的資料利用 callback function 帶入本地端。\n&lt;script href=&quot;https://another-origin.com/api/&quot;&gt;&lt;/script&gt;&lt;script&gt;  function receiveData (response) &#123;    console.log(response);  &#125;&lt;/script&gt;\n若此時 https://another-origin.com/api/ 返回的內容如下：\nreceiveData(&#123;  data: &#x27;test&#x27;&#125;);\n透過函式，那麼原本 html 中的 javascript 便可以存取來自其他網域的資料。\nJSONP 的缺點是附加的參數（例如：client-ID 等）只能透過附加在 url 上傳送，也只能使用 GET 方法發送 request，無法使用 POST 或其他 request 方法。\n","categories":["前端","JavaScript"],"tags":["JavaScript"]},{"title":"Linked List","url":"/2021/12/01/Linked%20List/","content":"tags: 資料結構與演算法Linked List 類似 Array\ngraph LRA -- next --&gt; B --&gt; C --&gt; D --&gt; NullA(nodeA)B(nodeB)C(nodeC)D(nodeD)\nfunction LinkedNode(val, next) &#123;  this.val = val || -1  this.next = next || null&#125;let list = new LinkedNodelet currentNode = listwhile(current)\n\n優點\n可以無限增加元素\n執行插入跟刪除時特別快\n\n\n缺點\n需要更多的 memory\n一定要從頭開始讀，儲存方式是不連續的（記憶體位置分散）\n反向讀取的話會很麻煩\n\n\n\nDoubly Linked List : 進階的 Linked List有往回指的屬性\ngraph LRA --&gt; B -- next --&gt; C --&gt; D --&gt; ED --&gt; C --&gt; B --&gt; AA --&gt; F A(nodeA)B(nodeB)C(nodeC)D(nodeD)E[null]F[null]","categories":["演算法"],"tags":["資料結構"]},{"title":"NoSQL 跟 SQL 的差別在哪裡？","url":"/2021/12/01/NoSQL%20%E8%B7%9F%20SQL%20%E7%9A%84%E5%B7%AE%E5%88%A5%E5%9C%A8%E5%93%AA%E8%A3%A1%EF%BC%9F/","content":"tags: 資料庫NoSQL是Not Only SQL的縮寫，與 SQL（關聯式資料庫）有以下差別：\n\n沒有 schema，通常以 JSON、XML 或 CSV 等檔案類型儲存\n用 key-value 來存資料\n不支援 JOIN\n通常用來存一些結構不固定的資料（log 之類的）\n\n","categories":["後端"],"tags":["SQL","NoSQL","資料庫"]},{"title":"MVC","url":"/2021/12/01/MVC/","content":"什麼是 MVC？MVC（Model–view–controller）是一種軟體的設計模式（design pattern），將軟體系統分為三個基本部分：模型（Model）、視圖（View）和控制器（Controller）。\n\nModel負責資料，包含資料的存取、處理方法與邏輯模式\nView負責圖形介面的顯示\nController負責控制不同軟體的流程\n\ngraph LRA[request] -- resquest --&gt; B[Controller]B --&gt; C((Model)) B -- data --&gt; D((View))C -- data --&gt; BD -- 完整的 response --&gt; BB -- response --&gt;A\n\nMVC 架構的出現是為了解決早期網頁中處理資料的程式與負責顯示的 html 混雜在一起，造成後續維護不易的的狀況。\n透過將 Model、View、Controller 分開，可以達成模組化的開發，例如多個 View 可以共用 Model，提升了程式碼的重用性。\n","categories":["設計模式"],"tags":["MVC","設計模式"]},{"title":"React 解決了什麼問題","url":"/2022/09/02/React%20%E8%A7%A3%E6%B1%BA%E4%BA%86%E4%BB%80%E9%BA%BC%E5%95%8F%E9%A1%8C/","content":"新工具的出現，是為了解決既有的問題而 React 做為一個 UI 的 JavaScript 的函式庫，它的出現便是為了解決 jQuery 以及原生 JavaScript 直接透過 DOM API 操作 DOM 時所衍生出的問題。\n那問題是什麼呢？\n重複渲染 DOM 過於消耗效能\n資料與畫面不一致\n\n接下來分別說明這兩點，以及 React 是透過什麼樣的方式找到解決方案。\n重複渲染 DOM 過於消耗效能直接操作 DOM 的方式容易造成效能上的負擔，影響特別大的就是其中兩項過程：\n\n回流（Reflow）：計算 Render Tree 上各項元素的物理屬性，例如位置、大小。\n重繪（Repaint）：將 Reflow 的計算結果轉換為螢幕上實際的像素顯示。\n\n由於每次的 Reflow 與 Repaint 需要重新計算所有節點，並且全部重新渲染，因此在架構較龐雜的網頁中每次的互動都需要耗費相當的資源。\n為了因應這種問題，React 以 Virtual DOM 來實現只更改畫面中有需要更新的元素，不必每次繪製畫面都得全部打掉重來，藉此提升效能。\n資料與畫面不一致若直接以 JavaScript 或 jQuery 設計網頁，網頁中的畫面需透過直接操作 DOM 的方式來改變，而資料則需要另外撰寫程式來控制。如果沒有刻意設計，網頁中的資料與畫面並不會隨時保持一致，對開發者而言，更動資料的同時也必須以另外寫程式去改變畫面，在維護與管理上較不容易。\nReact 的核心精神，與這個問題息息相關。透過 state，讓 UI 永遠由資料產生，藉此達到資料與畫面保持一致的目的。\n可以不用 React 嗎？雖然 React 可以解決傳統 HTML + JavaScript 的痛點，但它依舊只是一項工具，只是達到目的的千百種工具的其中一種。不過 React 的簡單、彈性以及有著豐富的生態系可以搭配，妥善運用的話可以大大地提昇開發效率與程式的重用性，不妨就嘗試看看巨人肩膀上的風景吧。\n","categories":["前端","React"],"tags":["react"]},{"title":"PHP 學習筆記","url":"/2021/12/01/PHP%20%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/","content":"安裝 XAMPP安裝 XAMPP 之後，執行 Apache 與 MySQL，點 Config，就能查到目錄。檔案會在 C:\\xampp\\htdocs 中。\n資料庫系統server &#x3D;&gt; 專門處理 request 跟 respone 的程式資料庫系統 &#x3D;&gt; 專門處理資料的程式\n關聯式資料庫\n關聯資料語言 SQL\nNoSQL (Not only SQL)例如MongoDB\nCLI &#x3D;&gt; mysql connectGUI &#x3D;&gt; 例如 phpMyAdmin\nphpMyAdmin \ntableSchema 結構每個表格都有 schemaphpMyAdmin 中可以從 schema &#x2F; 結構中檢視資料一定會有的是名稱與型態\n\n名稱：就是名稱\n型態：哪種儲存型態\n\nCHAR：固定長度（0 ~ 255）的字串，不足時會自右邊補足空白VARCHAR：可變長度（0 ~ 65,535）的字串，最大的有效長度需視資料列大小限制而定。\n通常字數較少會存成 VARCHAR，例如文章標題。字數較長會存成 TEXT，例如文章內文。\nPrimary Key (PK) 主鍵：不能為空，不能重複，最主要的，例如 id、會員帳號等unique 唯一：資料不能重複（PK 一定是唯一）index 索引：針對常查詢的欄位可以建立索引\nMySQLSelect 查詢資料SELECT * FROM `qoo` --查詢所有，從 qoo 資料庫SELECT * FROM qoo -- 可以加反引號也可以不加SELECT id FROM qoo -- 搜尋欄SELECT id, content FROM qoo -- 同時搜尋兩欄以 &quot;,&quot; 進行分隔SELECT id as name FROM qoo -- 查詢結果會 id 會以 name 顯示SELECT * FROM qoo WHERE id = 2 -- 查詢 id 為 2 的資料SELECT * FROM qoo where id = 1 and username = &#x27;Peter&#x27; -- and 查詢條件SELECT * FROM qoo where id = 1 or username = &#x27;Peter&#x27; -- or 查詢條件SELECT 10 FROM qoo -- 結果為 10\n\nInsert 新增資料INSERT INTO `qoo` (`username`, `content`) VALUES (&quot;username01&quot;, &quot;content01&quot;)\n\nUpdate 修改資料UPDATE `qoo` SET username = &quot;user01&quot;, content = &quot;content01&quot; WHERE id = 1\n\nDELETE 刪除資料DELETE FROM `qoo` WHERE id = 2\n\nPHPDisable cache開始前到開發人員工具的 Network，把 Disable cache 勾選起來。目前用的工具會暫存快取，可能會造成瀏覽器讀取到舊的資料。\nPHP 執行流程靜態檔案graph LRA[request] --&gt; B[Server]B --&gt; C[style.css]C --&gt; BB --&gt; A\n動態網站Server 有設定 .php 檔案會執行\ngraph LRA[request] --&gt; B[Server]B --&gt; C[style.css]C --&gt; D[執行 php]D --&gt; BB --&gt; A\nPHP 語法php 檔案中未用 &lt;?php ?&gt; 包住的程式碼會直接顯示\ndate 日期&lt;?php echo date(&quot;Y-m-d H:i:s&quot;) ?&gt;\n\n從前端傳資料給後端：GET 與 POST可以在網址加上 query string，例如：http://localhost:8080/peter/vivian/data.php?a=1當加上 query string 時，php 會自動給一個變數 $_GET\n\n假設網址是 ?a&#x3D;&amp;b&#x3D;，只有傳 key 沒有傳 value，isset 的結果依舊會是 true必須連 key 都沒有傳，isset 才會是 false因此針對這種檢查，會推薦使用 empty 來檢測，因為 empty 可以順便檢測空字串的狀況\n\n前端用表單，method 設為 GET，便能在網址中加上 query string。\n\n小技巧：開發工具勾選 Preserve log 可以查看發出的 request\n\n前後端溝通簡單範例（GET 表單）index.php\n&lt;?php  echo &quot;Who are you?&quot;?&gt;&lt;form method=&quot;GET&quot; action=&quot;data.php&quot;&gt;  name: &lt;input name=&quot;name&quot; /&gt;  age: &lt;input name=&quot;age&quot; /&gt;  &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;\n\ndata.php\n&lt;?php  if (!isset($_GET[&#x27;name&#x27;]) || !isset($_GET[&#x27;age&#x27;])) &#123; //其中一項資料沒填的條件    echo &#x27;資料有缺，請再次填寫&lt;br&gt;&#x27;;    exit();  &#125;    echo &quot;Hello!&quot; . $_GET[&#x27;name&#x27;] . &quot;&lt;br&gt;&quot;;  echo &quot;Your age is&quot; . $_GET[&#x27;age&#x27;] . &quot;&lt;br&gt;&quot;;?&gt;\n\n前後端溝通簡單範例（POST 表單）index.php\n&lt;?php  echo &quot;Who are you?&quot;?&gt;&lt;form method=&quot;POST&quot; action=&quot;data.php&quot;&gt;  name: &lt;input name=&quot;name&quot; /&gt;  age: &lt;input name=&quot;age&quot; /&gt;  &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;\n\ndata.php\n&lt;?php  if (empty($_POST[&#x27;name&#x27;]) || empty($_POST[&#x27;age&#x27;])) &#123;     echo &#x27;資料有缺，請再次填寫&lt;br&gt;&#x27;;    exit();  &#125;    echo &quot;Hello!&quot; . $_POST[&#x27;name&#x27;] . &quot;&lt;br&gt;&quot;;  echo &quot;Your age is&quot; . $_POST[&#x27;age&#x27;] . &quot;&lt;br&gt;&quot;;?&gt;\n\n從 PHP 連線到 MySQL 資料庫進 phpMyAdmin，新增使用者帳號全域權限可勾全選\n建立資料表編碼可用 utf8mb4_unicode_ci\n&lt;?php  $server_name = &#x27;localhost&#x27;;  $username = &#x27;huli&#x27;;  $password = &#x27;huli&#x27;;  $db_name = &#x27;huli&#x27;;  $conn = new mysqli($server_name, $username, $password, $db_name);  if ($conn-&gt;connect_error) &#123; //物件存取屬性用 -&gt;    die(&#x27;資料庫連線錯誤:&#x27; . $conn-&gt;connect_error); //die 執行完這行，接下來都不會執行  &#125;  $conn-&gt;query(&#x27;SET NAMES UTF8&#x27;); //設定編碼  $conn-&gt;query(&#x27;SET time_zone = &quot;+8:00&quot;&#x27;); //設定時區?&gt;\nPHP 與 MySQL 的互動CRUDCreateReadUpdateDelete\nPHP 與 MySQL 的互動：讀取資料要連線可以加上在 $conn 用 -&gt; 加上 query()\nconnn.php 建議在 git 中設定 ignore，避免密碼等敏感資訊放到網路上。\n每拿一筆資料需要 $result-&gt;fetch_assoc() 一次，可以用 while 迴圈來\n&lt;?phprequire_once(&#x27;conn.php&#x27;);  $result = $conn-&gt;query(&quot;SELECT * FROM users&quot;);  if (!$result) &#123;    die($conn-&gt;error);  &#125;  while ($row = $result-&gt;fetch_assoc()) &#123; //把對應的資料取出    echo &quot;id:&quot; . $row[&#x27;id&#x27;] . &#x27;&lt;br&gt;&#x27;;    echo &quot;username:&quot; . $row[&#x27;username&#x27;] . &#x27;&lt;br&gt;&#x27;;  &#125;?&gt;\n\nPHP 與 MySQL 的互動：新增資料sprintf() 字串組合，要帶進去的變數在文字中以 %d 表示數字、%s表示字串\nheader(&quot;Location: index.php&quot;) 回傳一個 response header，自動跳轉回 index.php\n&lt;?php  require_once(&#x27;conn.php&#x27;);  if (empty($_POST[&#x27;username&#x27;])) &#123;    die(&#x27;請輸入 username&#x27;);  &#125;  $username = $_POST[&#x27;username&#x27;];  $sql = sprintf(    &quot;insert into users(username) values(&#x27;%s&#x27;)&quot;,    $username  );  $result = $conn-&gt;query($sql);  if (!$result) &#123;    die($conn-&gt;error);  &#125;  header(&quot;Location: index.php&quot;);?&gt;\n\nPHP 與 MySQL 的互動：刪除資料顯示被影響的 row\n&lt;?php  echo $conn-&gt;affected_rows;?&gt;\n\n\n&lt;?php  require_once(&#x27;conn.php&#x27;);  if (empty($_GET[&#x27;id&#x27;])) &#123;    die(&#x27;請輸入 id&#x27;);  &#125;  $id = $_GET[&#x27;id&#x27;];  $sql = sprintf(    &quot;delete from users where id = %d&quot;,    $id  );  echo $sql . &#x27;&lt;br&gt;&#x27;;  $result = $conn-&gt;query($sql);  if (!$result) &#123;    die($conn-&gt;error);  &#125;  if ($conn-&gt;affected_rows &gt;= 1) &#123;    echo &#x27;刪除成功&#x27;;  &#125; else &#123;    echo &#x27;查無資料&#x27;;  &#125;  // header(&quot;Location: index.php&quot;);?&gt;\n\nPHP 與 MySQL 的互動：編輯資料&lt;?php  require_once(&#x27;conn.php&#x27;);  if (empty($_POST[&#x27;id&#x27;]) || empty($_POST[&#x27;username&#x27;])) &#123;    die(&#x27;請輸入 id 與 username&#x27;);  &#125;  $id = $_POST[&#x27;id&#x27;];  $username = $_POST[&#x27;username&#x27;];  $sql = sprintf(    &quot;update users set username=&#x27;%s&#x27; where id=%d&quot;,    $username,    $id  );  echo $sql . &#x27;&lt;br&gt;&#x27;;  $result = $conn-&gt;query($sql);  if (!$result) &#123;    die($conn-&gt;error);  &#125;  header(&quot;Location: index.php&quot;);?&gt;\n\n","tags":["PHP"]},{"title":"React 的思考模式","url":"/2022/09/02/React%20%E7%9A%84%E6%80%9D%E8%80%83%E6%A8%A1%E5%BC%8F/","content":"寫 React 時的思考模式與過往寫 HTML + JavaScript 的思考模式，個人認為最不一樣的兩點是：\n\n以元件（Component）為基本元素建構網頁\n由 state 來決定網頁的畫面\n\n以元件（Component）為基本元素建構網頁在 React 中，網頁是由大大小小的 Component 所組合而成。而這些 Component 的該如何切分，才能達到更好的重用性便是重點。\n對於初學 React 的新手來說，這與過去先將 HTML 寫好，再透過 JavaScript 改變 HTML 元素的方式很不一樣。在寫 Component 的同時就會需要考慮到這個 Component 會透過哪些 State 改變，需要傳什麼 props 給下一層等等問題。\n由 state 來決定網頁的畫面React 中很重要的一點是資料與畫面的一致。只要透過改變 state，畫面就可以跟著改變。\n我認為這是寫 React 時很方便的一點，只要事先將 Component 寫好，state 一改變，畫面就可以跟著改變，不需要額外的程式控制畫面。\n火鍋跟烤肉如果要比喻的話，傳統的 HTML + JavaScript 就像是火鍋，而 React 則是烤肉？？？（什麼意思）\n\n\n\n圖片來源：unsplash  & unsplash\n\n\nHTML 就像湯底，只能看沒得吃，要把食材（JavaScript）倒入才算是功能齊全、可以享用的美食。React 則像是烤肉，每一種食材（Component）都可以直接吃，有著各自的風味（功能），不過要把這些烤好的食材通通端出來才算是像樣的烤肉啊！\n比喻的不是很好，不過好餓喔…\n","categories":["前端","React"],"tags":["react"]},{"title":"Redux","url":"/2022/09/02/Redux/","content":"redux &#x3D;&gt; 狀態管理工具\njQuery -&gt; 資料與畫面分離Vue、Angular -&gt; 資料與畫面雙向綁定React -&gt; 只需要管資料\nflux 簡介看 facebook flux 影片原先可以直接從 View 去更改 Store(資料)flux 讓 view 需要透過 action 到 dispatcher 去更改資料好處是可以追蹤問題來源若專案規模小可能會造成資源浪費\nredux 簡介\nreact 把狀態放在 stateredux 把狀態放在 store\nconst &#123;createStore&#125; = require(&#x27;redux&#x27;)const initialState = &#123;  value: 0&#125;function counterReducer(stae = initialState, action) &#123;  if (action.type === &#x27;plus&#x27;) &#123;    return &#123;      value: state.value + 1    &#125;  &#125;  return state&#125;store.dispatch(&#123;  type: &#x27;plus&#x27;&#125;)\n\n訂閱 state 改變時要做的事情\nstore.subscribe(() =&gt; &#123;  console.log(&#x27;changed!&#x27;, store.getState())&#125;)\naction 中常會用的\n\ntype &#x3D;&gt; action 名稱\npayload &#x3D;&gt; 想要傳的參數\n\n避免 type 錯字難以 debug&#x3D;&gt; 字串改成 object\nconst ActionTypes = &#123;  ADD_TODO: &#x27;add_todo&#x27;,  DELETE_TODO: &#x27;delete_todo&#x27;&#125;\n\naction creattor\nreact-reduxselectorconst todos = useSelector((store) =&gt; store.todoReducer.todos)","categories":["前端","React"],"tags":["react","redux"]},{"title":"SPA","url":"/2021/12/01/SPA/","content":"tags: web 基礎Single Page Applicationsingle-page application 縮寫為 SPA，中文為「單一頁面應用程式」。其主要的概念是透過單一頁面達成的建立、讀取、修改與刪除資料等功能。\n相對於早期的網站設計主要採多頁設計，通常一個功能一個頁面，在資料傳送間必須重新載入頁面。\n而 SPA 的資料傳輸主要以 ajax 的方式進行，透過 ajax 資料可以在背景傳輸，讓資料存取功能在不切換頁面的情況下可以實現。\n由於早期的網站設計主要採多頁設計，不同功能或傳送資料時必須重新載入頁面，每次重新載入代表整個 html 畫面的重新繪製，需要較多的網路資源。\nSPA 的優缺點為何優點相較於採用多頁設計的網站，SPA 在存取資料時不需要重新載入頁，若網站中只有一部分資料更動，只需對該部份進行更新，達到較佳使用者體驗。\n缺點由於 SPA 的網站資料可能是由 JavaScript 等方式動態生成，因此搜尋引擎無法直接取得網站資料內容，對於 SEO 會有影響。\n","categories":["前端"],"tags":["web 基礎","SPA"]},{"title":"SQL Injection 的攻擊原理以及防範方法","url":"/2021/12/01/SQL%20Injection%20%E7%9A%84%E6%94%BB%E6%93%8A%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E9%98%B2%E7%AF%84%E6%96%B9%E6%B3%95/","content":"攻擊原理輸入特定含有 sql 語法的資料，讓 sql query 內容被竄改，達到符合攻擊目的。例如以下範例：\nSELECT * FROM hati8haha_users WHERE username = $username AND password = $password\n正常情況下變數 $username 與 $password 會帶入使用者輸入的資料，若有符合條件才會列出。但若將 $password 替換成 &#39; OR 1=1 # 那麼就會執行以下 sql query\nSELECT * FROM hati8haha_users WHERE username = &#x27;username&#x27; AND password = &#x27;&#x27; OR 1=1 #&#x27;\n因為 OR 1=1，因此無論輸入任何帳號密碼都可以取得身分認證成功登入。\n防範方法：Prepared statement將傳進去的資料用編譯後的參數替代，不會直接用原始資料進行 sql query\nphp 的 prepared statement 範例：\n$sql = &quot;insert into comments(nickname, content) values(?,?)&quot;;$stmt = $conn-&gt;prepare($sql);$stmt-&gt;bind_param(&#x27;ss&#x27;, $nickname, $content);$result = $stmt-&gt;execute();if (!$result) &#123;  die($conn-&gt;error);&#125;$result = $stmt-&gt;get_result()","categories":["前端"],"tags":["資安","資料庫","SQL Injection"]},{"title":"TCP / IP","url":"/2021/12/01/TCP%20_%20IP/","content":"網路的層級OSI 七層TCP &#x2F; IP 四層IPIPv4 IPv6 不同版本的 IP\n不同類型 IP固定 IP一台電腦一個 IP，server 會用固定 IP浮動 IP每次連線時 IP 不同虛擬 IP內網內可互相連接，外網無法連至內網 IP\nPORT區別同一台電腦上的不同服務HTTP：80HTTPS：443FTP：21\n表格\nSOAP Simple Object Acess Protocol透過 xml 進行資料交換\n不是 SOAP 的其他 HTTP APIRESTful它不是一個協定，是一種風格符合語意，直覺的方式\n","categories":["前端"],"tags":["web 基礎"]},{"title":"VARCHAR 跟 TEXT 的差別是什麼","url":"/2021/12/01/VARCHAR%20%E8%B7%9F%20TEXT%20%E7%9A%84%E5%B7%AE%E5%88%A5%E6%98%AF%E4%BB%80%E9%BA%BC/","content":"VARCHAR通常字數較少會存成 VARCHAR，例如文章標題。\n為可變長度（0 ~ 65,535）的字串，可自行設定最大的有效長度限制。\nTEXT字數較長會存成 TEXT，例如文章內文。\n純文字欄位，最大長度為同樣為 65,535，儲存時會附加 2 個位元組來記錄長度。\n","categories":["後端"],"tags":["資料庫"]},{"title":"Webpack 是做什麼用的","url":"/2021/12/01/Webpack%20%E6%98%AF%E5%81%9A%E4%BB%80%E9%BA%BC%E7%94%A8%E7%9A%84/","content":"Webpack 的官網是這樣介紹：\n\nAt its core, webpack is a static module bundler for modern JavaScript applications. When webpack processes your application, it internally builds a dependency graph which maps every module your project needs and generates one or more bundles.\n\nWebpack 是用來打包 JavaScript 應用程式的模組打包工具，它可以打包的範圍不僅限於 npm 等 JavaScript 模組，也包含 sass、圖片、壓縮工具等各種類型。它的運作方式是透過將各模組打包，並且建立關係對應表，讓所使用的模組可以對應到打包後的功能。\n在專案中常用會運用到的模組包含能轉換新語法為舊語法的 babel、程式碼最小化、壓縮、SCSS 或 npm packages 等。\n","categories":["前端"],"tags":["webpack"]},{"title":"display 的 inline, block 跟 inline-block 的差別是什麼？","url":"/2021/12/01/display_%20inline,%20block%20%E8%B7%9F%20inline-block%20%E7%9A%84%E5%B7%AE%E5%88%A5%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F/","content":"tags: HTMLdisplay: inline指行內元素，Content 的寬高會依據內容顯示，無法調整。左右 margin 可以調整，上下無法。左右 padding 可以調整，上下只會顯示背景的改變，但元素位置不會動。\n屬於 inline 的 html 元素包含 &lt;span&gt;、&lt;a&gt;、&lt;input&gt;、&lt;img&gt;\ndisplay: block會佔滿一整行，padding、border、margin 調整對整個元素都有影響。\n屬於 block 的 html 元素包含 &lt;div&gt;、&lt;ul&gt;、&lt;li&gt;、&lt;p&gt;、&lt;h1&gt;\ndisplay: inline-block對外像 inline 可以併排，對內像 block 可以調整屬性。\n請問 position: static, relative, absolute 跟 fixed 的差別是什麼？position: static預設的元素定位類型。當該元素定位類型為 position: static 時，top、right、bottom、left 和 z-index 屬性皆無效。\nposition: relative設定為 postion: relative 的元素可以透過top、right、bottom、left 和 z-index 等屬性改變定位。以此方式定位的元素不會影響其他的元素定位。\nposition: absoluteposition: absolute 會需要參考點進行定位，參考點會以最近的（上層）非 static 定位元素為參考點。以絕對定位定位的元素會被排除在預設排版之外，原本的空間會被接續的元素替補上。\nposition: fixed相對於瀏覽器做定位，位置可以固定定位在瀏覽器（更精確的說法為 viewport）上的位置，在頁面滾動不會隨頁面而上升或下降。\n","categories":["前端","HTML"],"tags":["HTML"]},{"title":"event delegation","url":"/2021/12/01/event%20delegation/","content":"event delegation 意思為事件代理。\n當網頁中有許多事件需要監聽，除了針對每一個事件增加監聽之外，透過 DOM 的事件傳遞機制，可以發現到若要觸發一個節點上的事件，該節點上層的所有節點都會經過捕獲與冒泡階段，這也代表可以透過在上層節點增加監聽事件，就可以達到對目標節點監聽的效果。\nevent delegation 的好處是可以節省資源，讓程式有更好的效能。此外，對於動態新增的事件也可以進行監聽。\n","categories":["前端"],"tags":["DOM","瀏覽器"]},{"title":"XSS 的攻擊原理以及防範方法","url":"/2021/12/01/XSS%20%E7%9A%84%E6%94%BB%E6%93%8A%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E9%98%B2%E7%AF%84%E6%96%B9%E6%B3%95/","content":"攻擊原理XSS 為 Cross-site Scriptinng 的縮寫，中文為「跨網站指令碼」。\n利用網站漏洞將帶有程式的 &lt;script&gt; 標籤或其它腳本程式注入網站，讓攻擊者可以取得更高的權限，例如讓網站重新導向至惡意連結或取得 cookie 等。\n防範方法：避免直接輸出\n跳脫若能將 &lt;script&gt; 經過編碼轉換，在 html 渲染時以純文字的方式印出，就能避免 XSS。\n過濾若需要將使用者輸入文字以 html 渲染出來，例如部落格文章中的 &lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt; 等標籤，則可以採用過濾的方式，把 script、iframe 等標籤針對性的不直接印出。\n\n","categories":["資安"],"tags":["資安","XSS"]},{"title":"include、require、include_once、require_once 的差別","url":"/2021/12/01/include%E3%80%81require%E3%80%81include_once%E3%80%81require_once%20%E7%9A%84%E5%B7%AE%E5%88%A5/","content":"include 與 require 都是用來引入既有的外部 php 檔案至目前檔案中執行。\n兩者差別在於若引入的檔案執行出現錯誤時，include 會產生 E_WARNING（非致命的執行時錯誤，程式會繼續執行），而 require 則會產生 E_COMPILE_ERROR（程式會停止）\ninclude_once、require_once 與 include、require 功能幾乎一樣，唯一的差別是 include_once、require_once 會先檢查要引入的檔案是否已經在該程式中被引入過，如果有的話就不會再次重複引入該檔案。\n","tags":["PHP"]},{"title":"state 跟 props 的差別","url":"/2022/09/02/state%20%E8%B7%9F%20props%20%E7%9A%84%E5%B7%AE%E5%88%A5/","content":"statestate 是管理元件的狀態，state 的值可以改變。\npropsprops 則是被傳遞進元件，用於父元件與子元件的溝通，值不可以改變。\n","categories":["前端","React"],"tags":["react"]},{"title":"event.preventDefault() 跟 event.stopPropagation() 差別","url":"/2021/12/01/event.preventDefault()%20%E8%B7%9F%20event.stopPropagation()%20%E5%B7%AE%E5%88%A5/","content":"event.preventDefault()取消事件的預設行為，例如避免送出表單或阻止超連結。但是不會影響事件傳遞，事件的捕獲與冒泡會正常傳遞。\nevent.stopPropagation()可以取消事件的傳遞，可以透過 target.addEventListener(type, listener, useCapture)  的第三個參數來控制要在捕獲階段還是冒泡階段取消事件傳遞。\n範例\n今天有一個 html 文件，html 中有 box1 與 box2 兩個區塊，並且對兩個區塊增加監聽事件。\n若 box1 事件被觸發，則會執行 console.log() 印出 box1。若 box2 事件被觸發，則會送出表單，並會執行 console.log() 印出 box2。\n情況一：無 event.preventDefault() 也無 event.stopPropagation()在此情況下 box1 與 box2 事件都被觸發，會送出表單並且同時印出 box1 與 box2。\n情況二：在 box2 中加上 event.preventDefault()此時表單不會被送出，但 box1 與 box2 都會被印出來。這邊的預設行為是送出表單，因為 event.preventDefault() 因此被取消了。由於事件傳遞依然會繼續，因此 box1 仍會被印出。\n情況三：在 box2 中加上 event.stopPropagation()此時表單會被送出，會印出 box2 但不會印出 box1。因為向上傳遞的事件被取消了，因此 box1 不會歷經冒泡階段，所以不會印出 box1。\n","categories":["前端"],"tags":["DOM","瀏覽器"]},{"title":"事件傳遞機制：冒泡 & 捕獲","url":"/2021/12/01/%E4%BA%8B%E4%BB%B6%E5%82%B3%E9%81%9E%E6%A9%9F%E5%88%B6%EF%BC%9A%E5%86%92%E6%B3%A1%20&%20%E6%8D%95%E7%8D%B2/","content":"DOM 的事件在傳遞時，是由根結點向下傳遞至目標，傳遞至目標後會依序向上傳遞。在這過程中，向下傳遞的過程被稱為捕獲階段（Capture Phase），而向上傳遞的過程則是冒泡階段（Bubbling Phase），在事件抵達目標時則會有目標階段（Target Phase）。\n因此事件傳遞的順序必然是「先捕獲，再冒泡」。\n下圖引用自 W3C，從下圖可看到整個事件的傳遞機制，是先發生捕獲階段，由根結點向下傳遞，抵達目標後，再發生冒泡階段，由目標向上傳遞回根節點。\n\n","categories":["前端"],"tags":["DOM"]},{"title":"svgr component 在 jest 無法被讀取","url":"/2022/09/02/svgr%20component%20%E5%9C%A8%20jest%20%E7%84%A1%E6%B3%95%E8%A2%AB%E8%AE%80%E5%8F%96/","content":"問題svgr 在 jest 中無法被讀取，執行測試時會報錯:::spoiler 錯誤訊息:::dangerError: Uncaught [Error: Element type is invalid: expected a string (for built-in components) or a class&#x2F;function (for composite components) but got: object.\nCheck the render method of YourComponent.]:::\n:::spoiler 套件版本\n:::info“next”: “12.2.5”,“react”: “18.2.0”,“jest”: “^29.0.1”,“jest-environment-jsdom”: “^29.0.1”,“@svgr&#x2F;webpack”: “^6.3.1”,:::\n解決方法建立 /mock/svg.js\nexport default &#x27;SvgrURL&#x27;export const ReactComponent = &#x27;div&#x27;\n\n修改 jest.config.js\nconst nextJest = require(&#x27;next/jest&#x27;)const customJestConfig = &#123;  setupFilesAfterEnv: [&#x27;&lt;rootDir&gt;/jest.setup.js&#x27;],  moduleDirectories: [&#x27;node_modules&#x27;, &#x27;&lt;rootDir&gt;/&#x27;],  testEnvironment: &#x27;jest-environment-jsdom&#x27;,&#125;const createJestConfig = nextJest(&#123;  dir: &#x27;./&#x27;,&#125;)(customJestConfig)module.exports = async () =&gt; &#123;  const jestConfig = await createJestConfig()  const moduleNameMapper = &#123;    &#x27;\\\\.svg$&#x27;: &#x27;&lt;rootDir&gt;/mock/svg.ts&#x27;,    ...jestConfig.moduleNameMapper,  &#125;  return &#123; ...jestConfig, moduleNameMapper &#125;&#125;","categories":["前端","React"],"tags":["react","svg","jest"]},{"title":"什麼是資料庫的 lock","url":"/2021/12/01/%E4%BB%80%E9%BA%BC%E6%98%AF%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%20lock/","content":"lock 是什麼資料庫的 lock 是指鎖住資料庫的狀態，不讓在 lock 狀態下的資料庫，資料無法更動。\n為了避免 race condition 發生，因此需要透過 lock 來將資料庫鎖定狀態。\nphp lock 範例程式碼$conn-&gt;autocommit(FALSE);  $conn-&gt;begin_transaction();  $conn-&gt;query(&quot;SELECT amount from products where id = 1 for update&quot;);  $conn-&gt;commit();  \n\n\n什麼是 race condition例如某網路商城的貨品 A 只剩下一件，小明和老王都同時下貨品 A 的訂單，而下訂單的程式邏輯為：\n1. 確認庫存數量大於或等於下單貨品數量2. 若結果為 false，則下單失敗；若為 true，繼續執行3. 庫存數量 - 下訂單貨品數量4. 購物車數量 - 下訂單貨品數量5. 帳戶訂單 + 下訂單貨品數量\n\n若小明訂單在步驟 12 結果為 「庫存數量大於或等於下單貨品數量」，還沒執行到步驟 3 時，老王的訂單就開始執行步驟 12，那麼就會造成兩人在步驟 1~2 結果都為 「庫存數量大於或等於下單貨品數量」。\n結果就是會造成程式會執行兩筆訂單的 3~5 步驟，造成超賣現象。而這種情形稱作 race condition。\n","categories":["後端"],"tags":["資料庫"]},{"title":"演算法筆記","url":"/2021/12/01/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98/","content":"What is Algorithm?演算法的定義\nAlgorithm is a finite sequence of well-defined, computer-implementable instructions, typically to solve a class of problems or to perform a computation.\nEasy speaking, algorithm is a step-by-step procedure to solve a problem.\n\n有限的連續性事情，有完整定義，電腦可以執行，是用來解決一個問題或計算某些值。一步一步去解決問題的程序，就可叫做演算法。\n現實生活中的演算法:\nGoogle Maps 的路徑規劃\nYouTube 的推薦影片\nExcel 的數字排列\n\nComparing Algorithm為什麼要比較演算法？比較速度、記憶體資源\n\nTime\nSpace\n\n現實情況中用計時方式來評估演算法時間效率並不實際，為什麼？\n\n同個電腦上會得到不同的結果\n不同電腦會給出不同的結果\n\nComplexity 複雜度需要用到多少 operations？ &#x3D;&gt; 直接影響\n$f(n) &#x3D; n^2+3n+4$n 為 input size複雜度為\n\n$f(n)$ 與 $n$ have quadrctic relations.有平方的關係\n設計演算法時應考慮避免把時間複雜度太高。\nBig O Notation定義\nBig O Notation is atool that describe the limiting behavior of a function when the argument tends towards a particular value or infinity.\nBig O Notation has a “worst case scenario”, which means it shows the general trends of complexity when the size of inputs is extremely large.\n\nBig O Notation 是用來描述 的工具n 不斷擴大時，會走去哪裡有一個最壞的情況的打算Big O Notation 會展示演算法的趨勢，當 size 到極大時，它的趨勢是什麼\nCalculating Big O Value\nConstant doesn’t matter 常數不重要\nSmall Terms don’t matter 較小的\nLongarithm Base doesn’t matter 底數（log 的）不重要\n\n$f(n) &#x3D; 5n^2+3n+4$ &#x3D;&gt; 只需要考慮 $5n^2$\nAsymptotic NotationBig O Omega 定義最低限度是多低Big Theta\nBig O 定義：The function $f(n)&#x3D;O(g(n)) iff  c, n0 s.t. 0 &lt;&#x3D; f(n)$ \ndesmos 繪圖計算機\nAnalysis of Arrays and ObjectsObject：Insertion $O(1)$Removal  $O(1)$Searching $O(n)$Acessing $O(1)$\nhash Table  &#x3D;&gt; 因此找到 Object 內的資料無論多龐大都是 $O(1)$\nArray：Insertion push &#x3D; $O(1)$ unshift &#x3D; $O(n)$Removal  pop &#x3D; $O(1)$ shift &#x3D; $O(n)$Searching $O(n)$Acessing $O(1)$\n因為 array 有 index，因此在最前面新增會需要更改所有的 index\n","categories":["演算法"],"tags":["資料結構","演算法"]},{"title":"建立 cesium React 專案","url":"/2022/08/12/%E5%BB%BA%E7%AB%8BcesiumReact%E5%B0%88%E6%A1%88/","content":"優缺點\n\n\n\n優點：模組累積數個專案經驗，有已經客製好的功能模組可用。具備擴充彈性。\n缺點：模組目前綁定固定功能，當模組持續擴充，可能會過於冗贅，如何管控和持續維護是要考量的點。\n\n\n\n\n用原生 Cesium 寫的模組結合 React 元件使用，建議直接引用 GIAP /core 中的模組檔案。\nResium優缺點\n\n* 優點：能以 React 元件方式寫 Cesium，與 React 整合度較高\n* 缺點：社群使用量不多，需考慮是否有潛在 bug 或因封裝而功能受限。\n\n\n\n\nResium 是提供 Cesium React 元件函式庫，讓 Cesium 模組可以元件化使用。\nResium 文件\n流程create react app\n缺點：開發時 hot reload 速度慢\n\n\n建立 react ts 專案\nyarn create react-app project-name --template typescript\n安裝 craco resium\nyarn add @craco/craco craco-cesium cesium## 若採用 Resium 則新增yarn add resium\n修改 package.json\n&#123; // ... &quot;scripts&quot;: &#123;   &quot;start&quot;: &quot;craco start&quot;, // react-scripts -&gt; craco   &quot;build&quot;: &quot;craco build&quot;, // react-scripts -&gt; craco   &quot;test&quot;: &quot;craco test&quot;,   // react-scripts -&gt; craco   &quot;eject&quot;: &quot;react-scripts eject&quot; &#125;, // ...&#125;\n建立 craco config\n在根目錄建立 craco.config.js\nmodule.exports = &#123;  plugins: [    &#123;      plugin: require(&quot;craco-cesium&quot;)()    &#125;  ]&#125;;\nyarn start 啟動專案\n\n\nvite\n優點：速度快\n缺點：社群小，版本不穩定\n\n\nvite 建立 react ts 專案\nyarn create vite project-name\n\n選擇 react ➡️ react-ts\n\n安裝 cesium、resium、必須插件\nyarn add cesiumyarn add --dev vite-plugin-cesium## 若採用 Resium 則新增yarn add resium\n完成\n\n\n優缺點\n\n如果跳出 error The requested module xxx does not provide an export named 'default'\n\n可參考此 issue，將 cesium 版本降至 1.95.0 以下即可解決\n\n2022&#x2F;08&#x2F;18 &#118;&#105;&#116;&#101;&#x2d;&#112;&#x6c;&#117;&#x67;&#105;&#110;&#45;&#x63;&#101;&#115;&#x69;&#117;&#x6d;&#64;&#49;&#46;&#x32;&#46;&#x32;&#x30; + &#99;&#101;&#x73;&#105;&#117;&#109;&#x40;&#49;&#x2e;&#57;&#53;&#x2e;&#x30; 可運作\n\n\n\n","categories":["前端"],"tags":["react","cesium","resium"]},{"title":"產品開發筆記","url":"/2021/12/01/%E7%94%A2%E5%93%81%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/","content":"工程師的一天 &#x2F; 兩周Sprint Planning - 0.5 day開發 + Daily Standup - 7.5 day部署 - 1 daySprint demo + Sprint retrospective - 1 day\n工程師怎麼知道要做什麼PM 會告訴你 XDD\n一個需求是怎麼產生的\nstakeholder 提出需求\nPM 開始撰寫 spec &#x3D;&gt; 功能\n畫 wireframe\n交給 designer 產生 mockup &#x3D;&gt; 畫面\n交給工程師開工\n\n功能 + 畫面 &#x3D; 工程師的工作\nProduct Requirement Document 產品需求文件Product Specifications 產品規格書規格盡可能與功能一致，工程師照規格做，有功能調整需請 PM 更新\n【SOP不藏私】系列＃EP1「連猴子也會的PRD指南」\nPRD到底该怎么写？更全面的文档范例来了：\n【產品經理 PM｜需求文檔 PRD】優惠券發放的產品設計，需求文檔怎麼寫？\nUser Story 使用者故事Task 任務 &#x3D; Card 卡片 &#x3D; Ticket 票 &#x3D; Issue 問題\n管理系統如 Jira\n軟體開發方法論 - Waterfall 瀑布流Methodology 方法論Waterfall 瀑布流從頭到下，比較不適合有新功能增加\nAgile 敏捷快速迭代、循環\n【文思不藏私】@敏捷宣言 12 原則\n\n什麼是敏捷?\n【敏捷系列 - 1】什麼是敏捷？敏捷實例分享\n\nWhat’s the Difference? Agile vs Scrum vs Waterfall vs Kanban\n【Podcast EP03】敏捷或瀑布開發哪個好？流程用哪種重要嗎？\n協助開發實作敏捷方法論的產品\n\nKanban\nScrum角色：\nProduct Owner：產品所有權、決定權（PM）\nScrumMaster：協助 Scrum 進行（通常團隊不一定有，或可能 PM 兼）\nTeam：執行者與 Kanban 主要差異在 Scrum 有固定的 Sprint（衝刺）\n\n\n\n協助做 retro 的工具：https://reetro.io/\nIntroduction to Scrum - 7 Minutes\n【敏捷系列 - 3】Scrum中的短衝 (Sprint)\n做完會部署到哪裡\nlocal 環境（本機）\ndevelopment 環境（dev）\nstaging 環境 &#x2F; qa 環境（對外看不到的 production 環境，用來測試）\nproduction 環境\n\n每個環境是不同 Server\nQA 會怎麼測試QA 只管功能出來有沒有錯\nSIT\t系統整合測試System Integration Testing\t\n只測試功能是否正確\nUAT\t使用者可用性測試User Acceptance Testing\t\n怎麼樣算是完成想了解更多產品相關的知識，可以參考：做產品真是哭夭難！ — Marty Cagan 演講 70 分鐘中文逐字翻譯（附贈 YouTube 錄影）\nhttps://medium.com/3pm-lab/marty-cagan-producttank-taipei-speech-933e7dfc13af\n","tags":["產品開發"]},{"title":"盒模型（box model）","url":"/2021/12/01/%E7%9B%92%E6%A8%A1%E5%9E%8B%EF%BC%88box%20model%EF%BC%89/","content":"html 中的可以看到的每個元素，都可以將它看作是盒模型。\n盒模型由四個部分組成，分別如下圖所示：\n\nContent （內容）Content 為盒模型中置入內容的元素，元素中的文字會在此區塊呈現。在預設（box-sizing: content-box;）情況下，可以透過 width 以及 height 控制寬高。\n\nPadding（內邊距）Padding 可以用來將 Content 往內推，背景色會與 Content 相同。可以透過 padding: 控制邊距的上下左右距離，越增加會將元素越往內推。\n\nBorder（邊框）Border 包在 Padding 的外層，若增加數值會向外延伸。可以透過 border: 控制邊框的上下左右寬度。設定 box-sizing: border-box; 時，width 與 height 控制的寬高會是以邊框為範圍。\n\nMargin（外邊距）Margin 的背景色永遠為透明。如果是 inline 元素，margin 的垂直方向 ( 上、下 ) 沒有效果。透過 margin: 設定的的外邊距上下左右寬度可以為負值。\n\n\npadding:、border:、margin: 的語法如下：\n\n單位可以設定為像素 px、百分比 % 或 em、rem 等。\n四個值：上、右、下、左。範例：padding: 36px 12px 24px 12px;\n三個值：上、左右、下。範例：border: 36px 12px 24px;\n兩個值：上下、左右。範例：margin: 36px 12px;\n一個值：上下左右。範例：border: 12px;\n\n","categories":["前端","HTML"],"tags":["HTML"]},{"title":"資料庫的 ACID","url":"/2021/12/01/%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%20ACID/","content":"Transaction 交易在以下情況中，會涉及多個以上的 query，而這些 query 必須確保所有動作都是成功且不受干擾。這類動作會被稱為 Transaction。\n\n轉帳\n購物（一次買多個品項）\n其他一次牽扯到多個 query 的操作\n\nphp 範例程式碼$conn-&gt;autocommit(FALSE);  $conn-&gt;begin_transaction();  $conn-&gt;query(&quot;update from money set amount = 20&quot;);  $conn-&gt;query(&quot;update from money set sum = 10&quot;);  $conn-&gt;commit();\n\nACID為了保證 Transaction 的正確性，要符合以下四個特性\n\n原子性 atomicity：只能全部失敗或全部成功\n一致性 consistency：維持資料的一致性（錢的總數相同）\n隔離性 isolation：多筆交易不會互相影響（不能同時改同一個值）\n持久性 durability：交易成功之後，寫入的資料不會不見\n\n這四個特性的字首縮寫便是 ACID。\n","categories":["後端"],"tags":["資料庫"]},{"title":"雜湊跟加密的差別","url":"/2021/12/01/%E9%9B%9C%E6%B9%8A%E8%B7%9F%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%AE%E5%88%A5/","content":"雜湊跟加密的最重要的差別是加密可以解密，而雜湊不行還原。因此密碼要雜湊過後才存入資料庫。\n加密 encryption透過演算法與 key，將字串計算得出加密後的密文，根據是否使用同一組 key 加密與解密可分為對稱加密法與與非對稱加密法。加密是一對一關係，若知道 key 跟演算法也會被解開\n明文 &#x3D;&gt; 加密 &#x3D;&gt; 密文密文 &#x3D;&gt; 解密 &#x3D;&gt; 明文\n雜湊 hash將字元丟進去某個公式計算的方式就叫做雜湊（Hash），而這個計算公式就稱為雜湊函數（Hash function）\n雜湊為多對一關係，這也是無法還原的原因\n明文 &#x3D;&gt; hash &#x3D;&gt; 文字\n若兩個不同密碼產生同個 hash 稱碰撞\n","categories":["資安"],"tags":["資安","資料庫"]}]